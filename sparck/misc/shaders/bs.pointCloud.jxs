<jittershader name="pointCloud">
	<description>Renders a mesh into a point cloud</description>
	<param name="encodeMode" type="int" default="0"/>
	<param name="bitDepthMode" type="int" default="0"/>

	<param name="cullNear" type="float" default="0."/>
	<param name="cullFar" type="float" default="10."/>

	<param name="distanceMin" type="float" default="0."/>
	<param name="distanceMax" type="float" default="4."/>

	<param name="pOff" type="vec2" default="319.909, 240.728"/>
	<param name="focal" type="vec2" default="386.323, 386.323"/>
	<param name="dim" type="vec2" default="640, 480"/>

  <param name="texdim" type="vec2" state="TEXDIM0" />
	<param name="image" type="int" default="0" />
	<language name="glsl" version="1.0">
		<bind param="encodeMode" program="vp" />
		<bind param="bitDepthMode" program="vp" />

	  <bind param="cullNear" program="vp" />
		<bind param="cullFar" program="vp" />

	  <bind param="distanceMin" program="vp" />
		<bind param="distanceMax" program="vp" />

	  <bind param="pOff" program="vp" />
	  <bind param="focal" program="vp" />
	  <bind param="dim" program="vp" />

	  <bind param="texdim" program="fp" />
		<bind param="image" program="vp" />
		<program name="vp" type="vertex">
<![CDATA[

uniform sampler2DRect image;

uniform int encodeMode;
uniform int bitDepthMode;

uniform float cullNear;
uniform float cullFar;

uniform float distanceMin;
uniform float distanceMax;

uniform vec2 pOff;
uniform vec2 focal;
uniform vec2 dim;

varying vec4 tc[5];
varying float distancePt;
varying vec4 verticeColor;

float decodedDepth;
float upperDepth;
float lowerDepth;

void main (void)
{
    tc[0] = gl_MultiTexCoord0;
		tc[1] = gl_MultiTexCoord0 + 1.0 / dim.x;
		tc[2] = gl_MultiTexCoord0 - 1.0 / dim.x;
		tc[3] = gl_MultiTexCoord0 + 1.0 / dim.y;
		tc[4] = gl_MultiTexCoord0 - 1.0 / dim.y;

		vec4 encodedDepth[5];
		float decodedDepth[5];
		float distance[5];

		bool drawing = true;

		for(int i = 0; i < 5; i++){
			encodedDepth[i] = texture2DRect(image, vec2(gl_TextureMatrix[0] * vec4(tc[i].x * 0.5, tc[i].y, tc[i].z, 1.)));

			decodedDepth[i] = encodedDepth[i].r; // square or linear
			if (bitDepthMode == 1){
				decodedDepth[i] = encodedDepth[i].g + encodedDepth[i].b / 255.0;
			}

			// calculate distance in [m]
			distance[i] = mix(distanceMax, distanceMin, decodedDepth[i]);
			if(abs(distance[0] - distance[i]) > 0.02){
				drawing = false;
			}
		}

		if(drawing){
			distancePt = distance[0];
			verticeColor = texture2DRect(image, vec2(gl_TextureMatrix[0] * vec4(tc[0].x * 0.5 + 0.5, tc[0].y, tc[0].z, 1.)));
		} else {
			distancePt = 100.0;
			verticeColor = vec4(1., 1., 1., 1.);
		}

		vec4 pt = vec4(((tc[0].xy * dim) - pOff) / focal * distancePt, - distancePt, 1.);

    vec4 mvPosition = gl_ModelViewMatrix * pt;

    //gl_PointSize = pixelSize * ( 300.0 / -mvPosition.z );

    gl_Position = gl_ProjectionMatrix * mvPosition;
}
]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[

//sinewave spatial distortion shader
uniform sampler2DRect image;

uniform float cullFar;

varying vec4 tc[5];
varying float distancePt;
varying vec4 verticeColor;

void main (void)
{
	// read color from color map
	vec4 color = vec4(0., 0., 0., 0.);

	if (distancePt < cullFar && verticeColor.a == 0.0){
		// read color from color map
		color = verticeColor;
	} else {
		discard;
	}

	//add to the input texture position
	gl_FragColor = vec4(color.rgb, 1.0);
}
]]>
		</program>
	</language>
</jittershader>
