<jittershader name="bs.portal.tex.proj.multi.direction.6-beam.jxs">
	<description>SPARCK - multi projection - Shader</description>
	<param name="stage_mode" type="int" default="0" />
	<param name="projection_mode" type="float" default="0" />

	<param name="beamer_enable" type="float" default="1. 1. 1. 1. 1. 1." />

	<param name="beamer_color" type="vec4" default="1. 0. 0. 1. 0. 1. 0. 1. 0. 0. 1. 1. 0. 1. 1. 1. 1. 0. 1. 1. 1. 1. 0. 1." />
	<param name="offColor" type="vec4" default="0. 0. 0. 1." />

	<param name="beamer_pos" type="vec3" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="beamer_dir" type="vec3" default="0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1." />
	<param name="beamer_up" type="vec3" default="1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0. 1. 0. 0." />

	<param name="beamer_m_matrix" type="mat4" default="1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1." />
	<param name="beamer_v_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="beamer_p_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="world_matrix" type="mat4" state="WORLD_MATRIX" />
	<param name="viewport_matrix" type="mat4" default="0.5 0. 0. 0. 0. 0.5 0. 0. 0. 0. 0.5 0. 0.5 0.5 0.5 0." />

	<param name="bevel_size" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="bevel_curve" type="float" default="1. 1. 1. 1. 1. 1." />
	<param name="bevel_round" type="int" default="0 0 0 0 0 0" />

	<param name="angle_mode" type="float" default="0.0" />

	<param name="angle_limit" type="float" default="0. 0. 0. 0. 0. 0." />
	<param name="angle_falloff" type="float" default="0.3 0.3 0.3 0.3 0.3 0.3" />

	<param name="blend_spread" type="float" default="1.0" />

	<param name="interpolation_correction" type="float" default="0.1" />

	<param name="collada_factor" type="mat4" default="1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1." />

	<param name="tex0" type="int" default="0" />
	<param name="tex1" type="int" default="1" />
	<param name="tex2" type="int" default="2" />
	<param name="tex3" type="int" default="3" />
	<param name="tex4" type="int" default="4" />
	<param name="tex5" type="int" default="5" />

	<language name="glsl" version="1.2">
		<bind param="tex0" program="fp" />
		<bind param="tex1" program="fp" />
		<bind param="tex2" program="fp" />
		<bind param="tex3" program="fp" />
		<bind param="tex4" program="fp" />
		<bind param="tex5" program="fp" />

		<bind param="beamer_enable" program="fp" />
		<bind param="beamer_color" program="fp" />

		<bind param="beamer_pos" program="fp" />
		<bind param="beamer_dir" program="fp" />

		<bind param="beamer_v_matrix" program="vp" />
		<bind param="beamer_p_matrix" program="vp" />

		<bind param="projection_mode" program="fp" />
		<bind param="stage_mode" program="fp" />

		<bind param="offColor" program="fp" />

		<bind param="world_matrix" program="vp" />
		<bind param="interpolation_correction" program="vp" />
		<bind param="collada_factor" program="vp" />
		<bind param="viewport_matrix" program="vp" />

		<program name="vp" type="vertex" source="bs.portal.tex.proj.multi.6.vertexshader.jxs" />

		<program name="fp" type="fragment">
<![CDATA[

// MIT License
// Martin Froehlich for tecartlab.com
// Copyright 2020 - tecartlab.com

uniform float projection_mode;
uniform int stage_mode;

// samplers
uniform sampler2DRect tex0;
uniform sampler2DRect tex1;
uniform sampler2DRect tex2;
uniform sampler2DRect tex3;
uniform sampler2DRect tex4;
uniform sampler2DRect tex5;

uniform float beamer_enable[6];
uniform vec4 beamer_color[6];

uniform vec3 beamer_dir[6];
uniform vec3 beamer_pos[6];

uniform vec4 offColor; 	// off color

uniform float interpolation_correction;

// generated by the vertex shader

varying vec4 beamer_uv[6];		// beamer uv position
varying vec2 beamer_texcoord[6];// beamer texcoord

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position

vec4 getTexture2DRect(int index, vec2 coord){
	if (index == 0){
		return texture2DRect(tex0, coord);
	} else if (index == 1){
		return texture2DRect(tex1, coord);
	} else if (index == 2){
		return texture2DRect(tex2, coord);
	} else if (index == 3){
		return texture2DRect(tex3, coord);
	} else if (index == 4){
		return texture2DRect(tex4, coord);
	} else if (index == 5){
		return texture2DRect(tex5, coord);
	}
}

vec4 getProjectorColor(int i){
	return (stage_mode == 0)?getTexture2DRect(i, beamer_texcoord[i]):beamer_color[i];
}

vec4 alphablend(vec4 src, vec4 dst){
	float outA = src.a + dst.a * (1.0 - src.a);
	return vec4((src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a))/outA, outA);
}

// entry point
void main()
{
	vec4 fragColor = vec4(0., 0., 0., 0.0);

	vec3 ray, raynormal;
	vec2 col;
	float angle;
	int i;

	for( i = 0; i < 6; i++){
		if(beamer_enable[i] == 1.){
			ray = beamer_pos[i] - worldPos;
			raynormal = normalize(ray);

			// calculate the angle between the surface normal and the projected beam.
			// 		rsp. the angle between the surface normal and the projector direction.
			angle = dot(normal, raynormal);

			// sets from which side (back, both, front) it is visible
			angle = (projection_mode == 0.)? 1.:max(sign(angle * projection_mode), 0.);

			// checks if the worldPos is in front of the camera.
			//   the interpolation_correction factor is making sure that fragment
			//   interpolation errors will be cut away, with the negative
			//   sideeffect of less total angle visibility.
			angle = angle * max(sign(dot(beamer_dir[i],raynormal)-interpolation_correction), 0.);

			// calculate the viewport linear box blend
			col = (0.5 - abs(beamer_uv[i].xy - 0.5));

			fragColor += getProjectorColor(i) * sign(clamp(min(col.x,col.y), 0., 1.)) * angle;
		}
	}
	gl_FragColor = alphablend(fragColor, offColor);
}

]]>
		</program>
	</language>
</jittershader>
